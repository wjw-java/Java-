

JVM 

## JVM是什么？

Java Virtual mechine （java 虚拟机），java虚拟机时实现 java代码能够运行在不同平台的重要原因，

.java 文件   通过编译器转为  .class （字节码）文件， .class 文件加载到  JVM 后 由 JVM 翻译为对应平台的机器码。

#### 魔术

标识是否 是正确的java字节码 。 Cafe Babe



## JVM结构

![](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211014152443683.png)



### 类加载子系统

##### 简介

* 类加载子系统负责从文件系统或网络中加载Class文件，Class文件开头有标识（魔术）
* ClassLoader 只负责文件加载，至于能否正确运行，由执行引擎决定。
* 加载类的信息放在 **方法区** 中除了类的信息外，**方法区中还会存放运行时常最池信息，可能还包括字符串字而量和数字常量(这部分常量信息是Class文件中常量池部分的内存映射)**



#### 类加载器



##### 简介

**在类的加载阶段中的加载阶段 .class 字节码文件在加载到JVM内存中需要借助类加载器进行加载**



作用：

1. 通过一个类的全限定名获取这个类的二进制字节流。

2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

3. 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口





##### 类加载器分类

* **启动类加载器 Bootstrap ClassLoader **

  **默认加载的是%JAVA_HOME%中lib下的jar包和class类文件**

  BootstrapClassLoader是顶级加载器，由C/C++语言编写 ，没有父类加载器，它不是java.lang.ClassLoader的子类。

​	

* **扩展类加载器 Extension ClassLoader** 

  **负责加载%JAVA_HOME%中lib/ext文件下的jar包和class类文件**

  由Java语言编写，父类加载器为启动类加载器 ，是ClassLoader的子类。

  （并不是继承启动类加载器 ，而是是ExtClassLoder中有一个parent变量是BootstrapClassLoader）

  

* **应用类加载器 Application ClassLoader**

  **负责加载classPath下的类文件**

  AppClassLoader是自定义加载器的父类,平时引用的jar包以及我们自己写的类都是这个加载器进行加载的，同时AppClassLoader还是线程上下文加载器，如果想实现一个自定义加载器的话就继承(extends)ClassLoader来实现

  

* **自定义类加载器**

  如何自定义类加载器？

  方法：新建一个类继承自java.lang.ClassLoader,重写它的findClass方法，调用loadClass方法即可





##### 双亲委派模型下的类加载过程

* **向上委派**

  Application ClassLoader 负责加载我们编写的class类，当它遇到一个新的class类的时候，不会直接进行加载，而是向上委派，查看扩展类加载器是否缓存了这个类，如果有则返回，如果没有则继续委派给BootstrapClassLoader，如果BootstrapClassLoader中缓存有则加载返回。

* **向下查找**

  如果启动类加载器没有该类的缓存，启动类加载器会查找加载自己路径也就是%JAVA_HOME%/lib下的jar与class类文件件,如果有则加载返回，没有则继续向下查找。ExtClassLoader也是做同样的操作。查找加载ExtClassLoader对应路径的文件，如果有则加载返回，没有则继续向下到AppClassLoader查找加载，AppClassLoader是加载classPath也就是我们程序员自己编写的class类，如果AppClassLoader找不到则会抛出找不到class类异常。

* **作用 ：保证 JVM 不加载重复的类，保证核心类库的安全**

  

![img](https://img-blog.csdnimg.cn/20210520101136530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjIzNDAw,size_16,color_FFFFFF,t_70)





##### 如何打破双亲委派模型？



**1.继承classLoader 重写其中的loadClass（）方法**

**2. SPI机制绕开loadclass () 方法**

* SPI ，全称为 Service Provider Interface，是一种**服务发现机制**。它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类。

  

原因：双亲委派机制的加载逻辑是写在loadClass 方法中的



在java1.2后才引入了双亲委派模型，因为虚拟在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。JDK1.2之后已不再提倡用户再去覆盖loadClass()方法，应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型的



#### 类加载过程



加载 --------链接--------初始化



##### 加载

由类加载器 将.class 文件加载到 JVM 内存中



##### 链接

* 验证

  保证Class文件中的字节流包含信息符合虚拟机要求，不会危害虚拟机自身安全

  

* 准备

  为类变量分区内存，设置变量的默认初始值 ：零值（数据类型初始值），在初始化过程才分配

  **如果是常量在编译时候就已经分配值**

  

* 解析

  将常量池内的符号引用替换为直接引用的过程。

  两个重点：

  - **符号引用**。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。
  - **直接引用**。可以理解为一个内存地址，或者一个偏移量。比如**类方法，类变量**的直接引用是指向方法区的**指针**；而**实例方法，实例变量**的直接引用则是从实例的头指针开始算起到这个实例变量位置的**偏移量**

  举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。

  在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。



### 运行时数据区



![image-20211014170901162](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211014170901162.png)





#### 程序计数器

是运行时数据区唯一一块不会OOM的区域，作用 **记录字节码指令**

CPU需要来回切换线程，需要程序计数器记录当前执行到了哪条指令



#### 虚拟机栈

![image-20211014171413459](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211014171413459.png)

![image-20211014211055746](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211014211055746.png)



##### 栈帧（Frame）

每个方法在执行的时候对应一个栈帧，每个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口



###### 局部变量表

**作用：存放方法中的局部参数**，底层是一个数组，每个结点看以看作一个变量槽，变量槽长度为32，因此long 和 double 需要两个槽，局部变量表的大小在创建时就确定。



###### 操作数栈

操作数栈的大小在创建时就确定，底层结构是数组，根据字节码指令往栈中存放取出数据



###### 动态链接

每一个栈帧的内部包含了一个执行运行时常量池中该栈帧所属方法的引用，这个引用的目的就是为了支持实现动态链接

**目的是:** 当前方法中如果需要调用其他方法的时候, 能够从运行时常量池中找到对应的符号引用, 然后将**符号引用转换为直接引用**,然后就能直接调用对应方法, 这就是动态链接。（不同于解析阶段，这里是动态的）

![image-20211014193541423](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211014193541423.png)



静态链接方法：包括: 调用静态方法, 调用实例的私有构造器, 私有方法, 父类方法

~~~java
public static methodA(){
    System.out.println("静态链接方法");
}
~~~



动态链接方法：动态方法





###### 方法返回地址



![image-20211014194825384](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211014194825384.png)

###### 附加信息

提供 JVM支持



##### 几道面试题 ![image-20211014195237344](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211014195237344.png)

方法局部变量是线程安全的吗？ 不安全。





#### 本地方法栈

管理本地方法的调用



#### 堆

运行时数据区中最大的空间，内存管理的核心部分。

在方法结束后，堆中的对象并不会马上移除，仅仅在垃圾收集的时候才会被移除，堆是执行垃圾回收的重点区域。



##### 堆内空间划分

![image-20211014200219732](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211014200219732.png)



* Java7及之前：新生代，老年代，永久代

* Java8及之后：新生代，老年代，元空间。



**默认情况 年轻代比老年代 为 1：2**

**伊甸园区 ：幸存者1区：幸存者2区 8：1：1(实际上由于自适应内存策略会有所偏差)**

![image-20211014205609636](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211014205609636.png)





###### 为什么要分为Eden和Survivor?为什么要设置两个Survivor区？

基于GC的性能考虑，java中的对象生命周期不同，一些生命周期长，一些生命周期短。

如果没有Survivor区就会直接触发垃圾回收时，大对象会直接进入老年代，老年代很快就会触发Full GC，Full GC消耗的时间长于young GC





##### 年轻代回收策略

![image-20211014200631986](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211014200631986.png)

* 次数 >= 16 进入老年代



##### 几种不同GC

* Minor GC （young GC）：
     触发机制：当年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden代满

    **Survivor满不会引发GC**

* Old GC  ：

  针对老年代的垃圾回收

* Full GC 和 Major GC：

  针对所有代（整个堆）的垃圾回收，Major GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old GC。



##### 内存分配策略

1. 优先分配到Eden区。

2. 大对象直接分配到老年代。尽量避免程序中出现过多大对象

3. 长期存活对象放在老年代。 



##### 元空间和永久代

* Java7及之前：新生代，老年代，永久代

* Java8及之后：新生代，老年代，元空间

![image-20211014203403916](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211014203403916.png)



**元空间与永久代区别是其内存空间直接使用的是本地内存**

**总结：在Jdk 1.7之前 ，运行时常量池（包含字符串常量池）存放在方法区中，此时方法区的实现是永久代，在Jdk 1.7字符串常量池被单独移植到堆中。Jdk1.8时，永久代改名为元空间。元空间使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。**



##### TLAB（Thread Local Allocation Buffer)

https://www.bilibili.com/read/cv10375688/



堆时线程共享的，在为对象分配内存空间时需要考虑线程安全问题。

在分配对象时 需要比较耗时的加锁操作，在开启TLAB的情况下，虚拟机会为**每个Java线程分配一块TLAB空间**在分配对象的时候首先会从这块内存空间开始分配，提供高了一定的性能。

但是这块TLAB通常较小，因此大对象无法在TLAB上进行分配，总是会直接分配在堆上。TLAB空间由于比较小，因此很容易装满。比如，一个100K的空间，已经使用了80KB，当需要再分配一个30KB的对象时，肯定就无能为力了。这时虚拟机会有两种选择，第一，废弃当前TLAB，这样就会浪费20KB空间；第二，将这30KB的对象直接分配在堆上，保留当前的TLAB，这样可以希望将来有小于20KB的对象分配请求可以直接使用这块空间。

![img](https://img-blog.csdn.net/20170829215419709?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhb21pbmdkZXRpYW54aWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



##### 对象分配的两种方法

指针碰撞(Serial、ParNew等带Compact过程的收集器)
假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump the Pointer）。
空闲列表(CMS这种基于Mark-Sweep算法的收集器)
如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。

![img](https://img-blog.csdn.net/20170719184539534?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhb21pbmdkZXRpYW54aWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)







##### 创建对象的方式

1. 使用构造方法 
2. Class 的 newInstance（）：使用反射的方式
3. 使用 clone() 方法 需要实现 Cloneable 接口 





##### 对象创建过程

![image-20211015085245912](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015085245912.png)



* ![image-20211015085336683](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015085336683.png)

  

* ![image-20211015085404757](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015085404757.png)



* ![image-20211015085440735](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015085440735.png)

* ![image-20211015085456443](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015085456443.png)



##### 对象的内存布局

一个对象由三部分组成：

1. 对象头
2. 实例数据
3. 对齐填充



###### 对象头

对象头由三部分组成：

1. Mark word 区

   * 线程持有锁
   * GC年龄
   * 对象HashCode值
   * 偏向线程ID
   * 锁状态标志

2. 类型指针

   类型指针指向对象的类元数据，虚拟机通过这个指针确定该对象是哪个类的实例

3. 数组大小

   如果是还需记录长度





###### 实例数据

底层是个数组，装载对象及其父类的属性信息，父类信息先填写。





###### 对齐填充

对象起始地址必须是8字节整数倍，当不是整数倍时，需要填充数据补齐







##### 堆是分配对象的唯一选择吗？



在JVM中，对象是在堆中分配的，这是一个普遍的常识，但是存在一种特殊情况，那就是如果经过**逃逸分析**后发现，一个对象并不能逃逸出方法的话，那么就可以被优化成栈上分配，这就不必在堆中分配，进行垃圾回收了。



**逃逸分析：**

不逃逸：如果一个对象，只在方法内作用，生命周期只在这个方法运行期间

逃逸：这个对象 被方法外的方法引用 ，那么就存在引用



例子：

![image-20211014225300453](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211014225300453.png)



###### 逃逸算法的作用

**基于逃逸算法的优化策略：**

![image-20211015091447411](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015091447411.png)







#### 方法区

![img](https://img-blog.csdnimg.cn/20200723170635605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDIyOTcx,size_16,color_FFFFFF,t_70)

* 用于存储被 JVM 加载的类信息，静态变量，常量 

* 永久代和元空间是方法区的实现，这样垃圾回收器就可以像管理 java 堆一样管理这部分内存，而不必为为方法区开发专门的内存管理器
*   **堆和方法区是物理连续，逻辑隔离的**



##### 为什么需要常量池

![image-20211015105318767](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015105318767.png)



##### 常量池分类

1. class 常量池

   用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)

   - 类和接口的全限定名
   - 字段的名称和描述符
   - 方法的名称和描述符

2. 运行时常量池

   jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的

3. 字符串常量池（底层是HashTable）

   字符串在java程序中被大量使用，为了避免每次都创建相同的字符串对象及内存分配，JVM内部对字符串对象的创建做了一定的优化，在Permanent Generation中专门有一块区域用来存储字符串常量池（一组指针指向Heap中的String对象的内存地址）



###### 为什么要将字符串常量池转移到堆中

**因为开发中常有大量字符串对象被创建，放在堆中可以提高回收的频率**



##### String 面试题



* intern ( ) 的使用

  如果不是使用双引号声明的String对象，可以使用String提供的intern()方法，intern()方法会从字符串常量池中查询当前字符串是否存在，若不存在则将当前字符串字面量放入常量池中，在返回其地址，如果存在直接返回其地址。

  

* ![image-20211015111000157](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015111000157.png)



​				第一题：两个对象 ，堆空间中一个，字符串常量池一个

​				第二题：对象1：StringBuilder对象 

​				对象2：new String(“a”) 对象3 常量池 a

​				对象4：new String(“b”) 对象5 常量池 6

​				对象6：toString方法 返回了一个 new String(“ab”)

​				此时字符串常量池不存在toString() ab；



* ![image-20211015111149571](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015111149571.png)



​			**如果两边存在变量实际上通过append 方法实现。**





## JVM垃圾回收机制



### 什么是垃圾

在程序运行期间没有被任何指针指向的对象，如果不及时请理，会导致内存溢出



### 为什么需要GC



如果不进行垃圾回收，内存迟早会用完，除了释放没有的内存对象，垃圾回收也可以清楚内存里的记录碎片，碎片整理将所占用的堆内存移到堆的另一端，一边JVM将着呢管理处的内存分配给新的对象。



早期的C++和C通过new和delete手动申请内存和回收内存。但使用不当容易造成内存泄漏最终导致内存溢出。而java提供自动的内存管理降低内存泄漏，溢出风险。



### GC关注的重点区域

堆区和方法区



### 内存泄漏与内存溢出

内存泄漏：对象应该被回收，但是 JVM 误认为该对象不应该回收的情况

#### 出现内存泄漏的情况

* 各种连接：

  如数据库连接，网络连接，IO连接 ，在创建连接时创建了各种对象 Connetcion，Statement，ResultSet等，如何不显示的关闭连接，那么这些对象是不会被垃圾回收器回收，从而造成内存泄漏

* 单例模式：

   单例对象在初始化中一般存在于整个JVM生命周期，如果这个单例对象持有某个生命周期较短的对象，那么这个对象可能不能被回收

* ThreadLocal 的内存泄漏

  ThreadLocalMap 内部的Entry 结点 继承WeakReference ，其中只有 Key值是弱引用修饰的，而其中Value是强引用的。因此这个Entry结点不能被垃圾回收，导致内存泄漏



### 垃圾回收算法



#### 垃圾标记阶段算法

用于确定该对象是否是垃圾，是否该回收

**分为以下两种：**



##### 引用计数算法（Java没有使用）

每个对象保存了一个引用计数器，用于对象被引用的情况。对于任何一个对象引用了A，则A的引用计数器+1；当引用失效时，计数器 减 1 。只要对象的引用计数器值为 0，即标识对象可能被垃圾回收。



![image-20211015112056967](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015112056967.png)



问题：循环引用 

![image-20211015115816658](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015115816658.png)



最开始引用为 null ，后续的对象都应该被回收，但是引用计数器非 0  ，因此没有被回收，最终导致**内存泄漏**，进而导致了内存溢出问题。



###### python中使用了引用计数算法是如何解决循环引用？

1. 手动解除
2. 使用弱引用



##### 可达性分析算法



通过一些被称为根结点对象 （GC Roots) 的对象为起点，通过这些结点开始向下所搜，所搜路径叫做

引用链 (Reference Chain)，当一个对象被引用链 直接或间接连接 则该对象被标记为不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记 过程。两次标记后仍然是可回收对象，则将面临回收。



###### 哪些对象能够作为 GC Roots

* 虚拟机栈中引用的对象
* 本地方法栈引用的对象
* 方法区类静态属性引用的对象

* 方法区中常量引用的对象

* Java虚拟机内部的引用 如系统类加载器，空指针异常对象



###### 对象的Finalize()方法

在对象被垃圾回收器回收时会调用该方法，一般用于在对象被回收时，进行资源的释放

注意：在这个方法中能够复活对象，尽量不要调用这个方法，不能保证它一定执行。







### 垃圾清除阶段算法



#### 标记-清除算法

最基础的垃圾回收算法，分为两个阶段，标记和清除



* 标记阶段

  从GC Roots 使用可达性分析算法进行标记，**标记其中可达对象**

* 清除阶段

  针对对象头没有被标记为可达的对象进行回收

![image-20211015144118964](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015144118964.png)



* 优点：实现简单

* 缺点：效率不高，会产生内存碎片，底部需要**维护一个空闲列表**





#### 复制算法



**将内存空间划分为两块，一次只使用其中的一块，在垃圾回收过程中，将存活的对象复制到未使用的另一块内存空间中，再将原先的使用的内存空间清空。**

![image-20211015143712916](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015143712916.png)



* 优点：实现简单，能够保证内存空间连续
* 缺点：需要两倍的空间，空间利用率低，此外如果存活对象多，需要消耗更多性能







#### 标记-压缩算法



为了保证内存空间连续引入的算法

* 标记阶段

  从标记存活的对象

* 压缩阶段

  将存活的对象按顺序压缩内存的一端，之后清理边界外的所有空间



* 优点：解决了标记-清除算法内存空间不连续的问题，解决了复制算法需要额外的空间问题
* 缺点:  效率较低，需要压缩对象



### 垃圾回收选择算法的



#### 分代垃圾回收算法

根据不同对象的生命周期，为 JVM 划分为不同的区域，根据不同的区域选择不同垃圾回收算法



#### 分区收集算法

将多个堆空间，划分为不同的小区间，每个小区间独立使用，独立回收。根据不同分区的回收价值，回收代价，进行对应的垃圾回收。

G1垃圾回收器依然是一个分代垃圾回收器。但是它与一般的回收器所不同的是，它引入了额外的概念，Region。G1垃圾回收器把堆划分成一个个大小相同的Region



#### 增量垃圾回收算法

复制算法，标记-清除算法，标记-压缩算法在进行垃圾回收时，在进行标记判断阶段都需要挂起用户进程，可能会造成一定的系统等待时间，影响用户体验，而增量垃圾回收算法思想在于**通过对线程间冲突的妥善处理，允许并发垃圾回收**





### 四种引用



**存在引用的对象都是可达对象**



#### 强引用

默认使用引用类型，使用 构造方法创建对象的方式使用的就是强引用，只要存在强引用关系，垃圾回收器一定不会回收这个对象



#### 软引用

软引用是可达的对象，在回收完不可达对象后，内存空间还是不够，那么就会将这些对象列入回收范围。

空间足够不回收，空间不够进行回收。

**实际应用：缓存**



#### 弱引用

弱引用也是可达的对象，但是垃圾回收器发现弱引用就会进行回收

**实际应用：ThreadLocal 释放系统资源（会导致内存泄漏）**



#### 虚引用

一个对象是否存在虚引用，不会影响垃圾回收的流程，虚引用用于在对象被回收时获取系统通知或释放资源



### Stop The World

指的是的垃圾回收过程，需要暂停用户程序，频繁的STW会影响用户体验



产生原因：

可达性分析算法工作时必须在一个能确保一致性的快照中进行，如果在分析过程，对象引用关系还在变更，那么解决是不准确的。



**程序并非在任何点都能停下来，只有在安全点才能停下。**



![image-20211015155454922](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015155454922.png)







## 垃圾回收器



**java8默认使用的垃圾回收器：Parallel Scavenge + Parallel Old**





### 垃圾回收器分类



**1.根据使用垃圾回收线程个数分类：**

串行垃圾回收器，并性垃圾回收器



**2.根据工作区域分类：**

新生代垃圾回收器，老年代垃圾回收器



**3.根据工作模式：**

并发垃圾回收（垃圾回收器和用户程序并发执行），独占垃圾回收



### 七款垃圾回收器



* 串行垃圾回收器：Serial ，Serial Old
* 并行垃圾回收器：ParNew ，Parallel Scavenge ，Parallel Old
* 并发垃圾回收器：CMS ，G1

![image-20211015152340312](C:\Users\W J C\AppData\Roaming\Typora\typora-user-images\image-20211015152340312.png)





#### Serial

最早的垃圾回收器，jdk1.3之前的唯一选择，是串行的垃圾回收器，HotSpot虚拟机在Client模式下默认使用的垃圾回收器，作用于新生代，采用的复制算法。



* 优点：简单高效
* 缺点：并发能力差，web应用下基本不会使用



#### Serial Old

是 Serial 垃圾回收器的老年代版本，单线程的垃圾回收器，使用的标记-压缩算法。HotSpot虚拟机在Client模式下默认使用的垃圾回收器



#### ParNew

是 Serial 垃圾回收器的多线程版本，采用的是复制算法，除了支持多线程进行垃圾回收之外和 Serial 基本一致。与CMS GC 组合使用。



#### Parallel Scavenge

是新生代垃圾回收，是多线垃圾回收器，采用复制算法，和 ParNew 性能类似，不同点在于Parallel Scavenge 关注程序的吞吐量。 吞吐量 ： 用户程序执行时间 / 用户程序执行时间 + 垃圾回收时间



#### Parallel Old

在 jdk1.6 提供 代替Serial Old 垃圾回收器，是老年代垃圾回收器，使用标记-压缩算法，和Parallel Scavenge 组合使用



#### CMS 

**全称为 Concurrent - Mark - Sweep 并发标记清除**  ，在 jdk1.5 推出，用于**老年代垃圾回收 **。第一次实现了垃圾回收线程和用户线程一起工作，关注点是尽可能的降低垃圾回收期间，用户线程暂停的时间。

**遗憾的是 CMS 不能与 Parallel Scavenge 共同使用** 因为实现的框架不同





##### CMS工作原理

* 初始标记

  在个阶段仅仅 标记出 GC ROOTS 能够关联到的对象，在这个阶段中，程序中所有工作线程会因为 Stop The

   World 而暂停，但是这个时间十分短暂

  

* 并发标记

  从GC roots直接关联的对象开始变量整个引用链，这个过程耗时较长，但是不需要停顿用户线程，可以并发运行。

  

* 重新标记

  在并发标记阶段，因为用户线程和垃圾回收线程一起执行，一些标记是不准备的，在这个阶段需要重新标记，标记时间较短，仍然需要暂停用户线程

  

* 并发清除

  清除不可达的对象，不需要暂停用户线程，耗时较长。



### G1 垃圾回收器 



